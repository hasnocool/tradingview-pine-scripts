Script Name: Eltrut
Author: ninjasoar
Description: Turtle inverted.

Long when
1. 7 period high broken
2. trendflex below 1
3. inside 35,3 bollinger band
PineScript code:

Pine Script™ strategy
Eltrut
Copy code
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
//@version=4
strategy("Eltrut", shorttitle="Eltrut Strat", overlay=true, pyramiding=0, default_qty_type= strategy.percent_of_equity,calc_on_order_fills=false, slippage=0,commission_type=strategy.commission.percent,commission_value=0.05)
testStartYear = input(2016, "Backtest Start Year")
testStartMonth = input(1, "Backtest Start Month")
testStartDay = input(1, "Backtest Start Day")
testPeriodStart = timestamp(testStartYear,testStartMonth,testStartDay,0,0)
testStopYear = input(2030, "Backtest Stop Year")
testStopMonth = input(12, "Backtest Stop Month")
testStopDay = input(30, "Backtest Stop Day")
testPeriodStop = timestamp(testStopYear,testStopMonth,testStopDay,0,0)
// R E F L E X / T R E N D F L E X
f_supersmoother(_src,_len)=>
    pi = 2 * asin(1)
    _a = exp(-sqrt(2) * pi / _len)
    _c2 = 2 * _a * cos(sqrt(2) * pi / _len)
    _c3 = -_a * _a
    _c1 = 1 - _c2 - _c3
    _out = 0.0
    _out := _c1 * _src + _c2 * nz(_out[1],nz(_src[1],_src)) + _c3 * nz(_out[2],nz(_src[2],nz(_src[1],_src)))
f_IQIFM(_src1,_max)=>
    _src = _src1 < 0.001 ? _src1 * 10000 : _src1
    _imult = 0.635, _qmult = 0.338 , _inphase = 0.0, _quad = 0.0
    _re = 0.0, _im = 0.0, _deltaphase = 0.0, _instper = 0.0, _per = 0.0, _v4 = 0.0
    _v1 = _src - nz(_src[7])
    _inphase := 1.25 * (nz(_v1[4]) - _imult * _v1[2]) + _imult * nz(_inphase[3])
    _quad := _v1[2] - _qmult * _v1 + _qmult * nz(_quad[2])
    _re := 0.2 * (_inphase * _inphase[1] + _quad * _quad[1]) + 0.8 * nz(_re[1])
    _im := 0.2 * (_inphase * _quad[1] - _inphase[1] * _quad) + 0.8 * nz(_im[1])
    if _re != 0.0
        _deltaphase := atan(_im / _re)
    for i = 0 to _max
        _v4 := _v4 + _deltaphase[i]
        if _v4 > 4 * asin(1) and _instper == 0.0
            _instper := i
    if _instper == 0.0
        _instper := nz(_instper[1])
    _per := 0.25 * _instper + 0.75 * nz(_per[1])
    _per
f_flex(_src1, _fixed_len, _reflex) =>
    _src = _src1
    _len = _fixed_len 
    _ss1 = f_supersmoother(_src, _len)
    _ss = _ss1
    _slope = (_ss[_len] - _ss) / _len
    _sum = 0.0
    for _i = 1 to _len
        _c1 = _reflex ? _ss + _i * _slope - _ss[_i] : _ss - _ss[_i]
        _sum := _sum + _c1
    _sum := _sum / _len
    _ms = 0.0
    _ms := 0.04 * pow(_sum,2) + 0.96 * nz(_ms[1])
    _flex1 = _ms != 0 ? _sum / sqrt(nz(_ms)) : 0.0
    _flex = _flex1
    _flex
rflx = f_flex(close, 20, true)  
trndflx = f_flex(close, 20, false)   
// S I G N A L
fractal_cond_up = high[2] > high[3] and high[2] > high[4] and high[2] > high[1] and high[2] > high[0]
fractal_up = valuewhen(fractal_cond_up, high[2], 0)
fractal_cond_dn = low[2] < low[3] and low[2] < low[4] and low[2] < low[1] and low[2] < low[0]
fractal_dn = valuewhen(fractal_cond_dn, low[2], 0)
long_cond = crossunder(close, fractal_dn)
short_cond = crossover(close, fractal_up)
// F I L T E R S
[diplus, diminus, ADX14] = dmi(14, 14)
long_filter1 = ADX14 > 25
short_filter1 = ADX14 > 25
basis = sma(close, 50)
dev = 3 * stdev(close, 50)
long_filter2 = close > basis - dev
short_filter2 = close < basis + dev
// S T R A T E G Y
long = long_cond and long_filter1 and long_filter2
short = short_cond and short_filter1 and short_filter2
long_price = valuewhen(long and strategy.position_size <= 0, close, 0)
short_price = valuewhen(short and strategy.position_size >= 0, close, 0)
    
if( time >= testPeriodStart and time <= testPeriodStop)
    strategy.entry("Long", strategy.long, when = long)
    strategy.entry("Short", strategy.short, when = short)
    
sl_amt = atr(50) * 3
tp_amt = atr(50) * 10
long_sl_price = long_price - sl_amt
short_sl_price = short_price + sl_amt
long_tp_price = long_price + tp_amt 
short_tp_price = short_price - tp_amt
if strategy.position_size > 0 
    strategy.exit(id="Long", stop=long_sl_price, limit=long_tp_price)
    strategy.close("Long", when=short)// or crossunder(low,long_sl_price) or crossover(high, long_tp_price))
if strategy.position_size < 0 
    strategy.exit(id="Short", stop=short_sl_price, limit=short_tp_price)
    strategy.close("Short", when=long)// or crossover(high,short_sl_price) or crossunder(low, short_tp_price))
// P L O T 
plotshape(long, color = #1e90ff, text = "", style=shape.triangleup, location=location.belowbar, size=size.tiny)
plotshape(short, color = #ff69b4, text = "", style=shape.triangledown, location=location.abovebar, size=size.tiny)
alertcondition(long, "Long", "Enter Long")
alertcondition(short, "Short", "Enter S")
Expand (120 lines)